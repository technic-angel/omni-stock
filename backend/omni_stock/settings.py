"""
Django settings for omni_stock project.

Generated by 'django-admin startproject' using Django 5.0.6.
"""
import os
from datetime import timedelta
from pathlib import Path
from urllib.parse import urlparse

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Minimal env helper to avoid requiring the "environ" package.
# This will read a local .env file into os.environ (if present) and provide
# env(...) and env.bool(...) compatible calls used below.

# Read the .env file if it exists (for local debugging outside of Docker)
# In Docker, the variables are passed directly from docker-compose.yml, but this is safe.
_env_path = os.path.join(BASE_DIR.parent, '.env')
if os.path.exists(_env_path):
    with open(_env_path, encoding='utf-8') as _f:
        for _line in _f:
            _line = _line.strip()
            if not _line or _line.startswith('#'):
                continue
            if '=' in _line:
                _k, _v = _line.split('=', 1)
                _k = _k.strip()
                _v = _v.strip().strip('"').strip("'")
                # Don't overwrite existing environment variables
                os.environ.setdefault(_k, _v)

def _parse_bool(value, default=False):
    if value is None:
        return bool(default)
    return str(value).strip().lower() in ('1', 'true', 'yes', 'y', 'on')

def _parse_list(value, default=None):
    if value is None or value == '':
        return default or []
    return [item.strip() for item in value.split(',') if item.strip()]

class SimpleEnv:
    def __call__(self, name, default=None):
        return os.environ.get(name, default)
    def bool(self, name, default=False):
        return _parse_bool(os.environ.get(name), default)
    def list(self, name, default=None):
        return _parse_list(os.environ.get(name), default)

env = SimpleEnv()


# SECURITY WARNING: keep the secret key used in production secret!
# Use the DJANGO_SECRET_KEY environment variable defined in .env.
# For local development only, we allow a fallback value if DEBUG is True.
SECRET_KEY = env('DJANGO_SECRET_KEY', default='django-insecure-default-fallback-key')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = env.bool('DEBUG', default=True)

# Fail fast if running in non-debug mode without a proper secret key.
if not DEBUG and (not SECRET_KEY or SECRET_KEY == 'django-insecure-default-fallback-key'):
    raise RuntimeError('DJANGO_SECRET_KEY must be set when DEBUG is False. Set it in your .env file.')

# ALLOWED_HOSTS configuration
# Supports both explicit hosts and Render preview domains
_allowed_hosts = env.list('ALLOWED_HOSTS', default=['*'] if DEBUG else [])

# Auto-detect Render.com domains (production and PR previews)
# Render sets RENDER_EXTERNAL_HOSTNAME for the current service
_render_host = os.environ.get('RENDER_EXTERNAL_HOSTNAME')
if _render_host:
    _allowed_hosts.append(_render_host)

# Allow all Render preview domains (pattern: *-pr-*.onrender.com)
_render_service = os.environ.get('RENDER_SERVICE_NAME')
if _render_service:
    # Add base service domain
    _allowed_hosts.append(f'{_render_service}.onrender.com')
    # Also allow PR preview pattern
    _allowed_hosts.append('.onrender.com')  # Allows all *.onrender.com subdomains

ALLOWED_HOSTS = list(set(_allowed_hosts))  # Remove duplicates


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Third-party Apps
    'rest_framework',
    'rest_framework_simplejwt',
    'rest_framework_simplejwt.token_blacklist',  # For logout functionality
    # Third-party utilities
    'corsheaders',
    'admin_thumbnails',
    'drf_spectacular',
    # Local Apps 
    'backend.core.apps.CoreConfig',
    'backend.users.apps.UsersConfig',
    'backend.vendors.apps.VendorsConfig',
    'backend.inventory.apps.InventoryConfig',
]

AUTH_USER_MODEL = 'users.User'

MIDDLEWARE = [
    # CORS middleware should be placed as high as possible
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

# CORS: allow requests from frontend during development. For production,
# set specific origins via `CORS_ALLOWED_ORIGINS`.
_default_cors_origins = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    # Vite default dev server port used by frontend
    "http://localhost:5173",
    "http://127.0.0.1:5173",
]

# Auto-add Render backend URLs to CORS allowed origins
if _render_host:
    _default_cors_origins.append(f'https://{_render_host}')
if _render_service:
    _default_cors_origins.append(f'https://{_render_service}.onrender.com')

CORS_ALLOWED_ORIGINS = env.list('CORS_ALLOWED_ORIGINS', default=_default_cors_origins)

# Allow Render/Vercel HTTPS domains via regex patterns
CORS_ALLOWED_ORIGIN_REGEXES = [
    r"^https?://(localhost|127\.0\.0\.1):\d+$",
    r"^https://.*\.onrender\.com$",  # All Render domains including PR previews
    r"^https://.*\.vercel\.app$",     # All Vercel preview deployments
]

# CSRF trusted origins - add Render domains automatically
_csrf_origins = env.list('CSRF_TRUSTED_ORIGINS', default=[])
if _render_host:
    _csrf_origins.append(f'https://{_render_host}')
if _render_service:
    _csrf_origins.append(f'https://{_render_service}.onrender.com')
    # Add wildcard pattern for PR previews
    _csrf_origins.append('https://*.onrender.com')

CSRF_TRUSTED_ORIGINS = list(set(_csrf_origins))  # Remove duplicates

# Smart FRONTEND_URL configuration
# Try to auto-detect from CORS_ALLOWED_ORIGINS if not explicitly set
_frontend_url_env = env('FRONTEND_URL', default=None)
if _frontend_url_env:
    FRONTEND_URL = _frontend_url_env
else:
    # Auto-detect from CORS_ALLOWED_ORIGINS (prefer Vercel over localhost)
    _detected_frontend = None
    for origin in CORS_ALLOWED_ORIGINS:
        if 'vercel.app' in origin and origin.startswith('https://'):
            _detected_frontend = origin
            break
        elif 'onrender.com' in origin and 'backend' not in origin and origin.startswith('https://'):
            _detected_frontend = origin
    FRONTEND_URL = _detected_frontend or 'http://localhost:5173'

def _extract_origin(url: str | None) -> str | None:
    if not url:
        return None
    parsed = urlparse(url)
    if not parsed.scheme or not parsed.netloc:
        return None
    return f'{parsed.scheme}://{parsed.netloc}'

_frontend_origin = _extract_origin(FRONTEND_URL)
if _frontend_origin:
    if _frontend_origin not in CORS_ALLOWED_ORIGINS:
        CORS_ALLOWED_ORIGINS.append(_frontend_origin)
    if _frontend_origin not in CSRF_TRUSTED_ORIGINS:
        CSRF_TRUSTED_ORIGINS.append(_frontend_origin)

ROOT_URLCONF = 'backend.omni_stock.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'backend.omni_stock.wsgi.application'


# Database Configuration
# This is where we dynamically set the database based on environment variables
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': env('POSTGRES_DB'),
        'USER': env('POSTGRES_USER'),
        'PASSWORD': env('POSTGRES_PASSWORD'),
        'HOST': env('POSTGRES_HOST'), # This must be 'db', the service name in docker-compose.yml
        'PORT': env('POSTGRES_PORT'),
        'OPTIONS': {
            'sslmode': env('POSTGRES_SSL_MODE', default='prefer'),
        },
    }
}

# Handle Render's DATABASE_URL if present (overrides individual settings)
import dj_database_url
if 'DATABASE_URL' in os.environ:
    DATABASES['default'] = dj_database_url.config(
        conn_max_age=600,
        conn_health_checks=True,
        ssl_require=True,
    )


# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# Use leading slashes for URL settings so `static()` and other helpers
# generate correct URL patterns. Define MEDIA settings to avoid adding a
# catch-all static pattern when MEDIA_URL is missing.
STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'

# Media files (user-uploaded content)
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

# File Storage Configuration
# --------------------------
# Dynamically choose storage backend based on environment
# Local: FileSystemStorage (saves to backend/media/)
# Production: SupabaseStorage (uploads to Supabase cloud)
USE_SUPABASE_STORAGE = env.bool('USE_SUPABASE_STORAGE', default=False)

if USE_SUPABASE_STORAGE:
    # Supabase Storage Configuration
    # These are S3-compatible settings for django-storages
    AWS_ACCESS_KEY_ID = env('SUPABASE_STORAGE_ACCESS_KEY')
    AWS_SECRET_ACCESS_KEY = env('SUPABASE_STORAGE_SECRET_KEY')
    AWS_STORAGE_BUCKET_NAME = env('SUPABASE_STORAGE_BUCKET', default='omni-stock-media')
    AWS_S3_ENDPOINT_URL = env('SUPABASE_STORAGE_ENDPOINT')
    AWS_S3_CUSTOM_DOMAIN = env('SUPABASE_STORAGE_CUSTOM_DOMAIN', default=None)
    
    # S3 settings for Supabase compatibility
    AWS_S3_OBJECT_PARAMETERS = {
        'CacheControl': 'max-age=86400',  # Cache for 1 day
    }
    AWS_DEFAULT_ACL = 'public-read'
    AWS_QUERYSTRING_AUTH = False
    AWS_S3_FILE_OVERWRITE = False  # Don't overwrite files with same name
    
    # Django 4.2+ STORAGES format (replaces deprecated DEFAULT_FILE_STORAGE)
    STORAGES = {
        "default": {
            "BACKEND": "backend.core.storage_backends.SupabaseStorage",
        },
        "staticfiles": {
            "BACKEND": "django.contrib.staticfiles.storage.StaticFilesStorage",
        },
    }
else:
    # Local development: Use FileSystemStorage (default)
    # Files saved to backend/media/ directory
    # Django 4.2+ STORAGES format (replaces deprecated DEFAULT_FILE_STORAGE)
    STORAGES = {
        "default": {
            "BACKEND": "django.core.files.storage.FileSystemStorage",
        },
        "staticfiles": {
            "BACKEND": "django.contrib.staticfiles.storage.StaticFilesStorage",
        },
    }

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

REST_FRAMEWORK = {
    # Set JWT as the default authentication class globally
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    # Set the default permissions to allow unauthenticated access for now.
    # We will change this to IsAuthenticated later in the roadmap (P3.4)
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ),

    # Use drf-spectacular for schema generation when installed
    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema'
}

# Optional drf-spectacular settings can be added here if needed later
# SPECTACULAR_SETTINGS = {
# }

SIMPLE_JWT = {
    # JWT lifespan settings
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=5),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': True,
    'BLACKLIST_AFTER_ROTATION': True,  # Blacklist old tokens on rotation
    'AUTH_HEADER_TYPES': ('Bearer',),
    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
}

SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
SESSION_COOKIE_SECURE = not DEBUG
CSRF_COOKIE_SECURE = not DEBUG
